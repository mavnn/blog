#+TITLE: Mavnn's blog

* Log in, log out (part 2)
:PROPERTIES:
:RSS_PERMALINK: 2024/03/05/dev_journal_4_2.html
:PUBDATE: 2024-03-05
:ID:       D439156E-BC4E-4738-9F4A-68E0970D903D
:END:
#+begin_quote
This post is the second half of a two part update in the "Dev Journal" series. [[file:../../../2024/03/01/dev_journal_4.org][The first half]] talks about adding dependencies to the project on postgresql and the Marten event store library, which we'll look at using in this post. [[file:../../../2024/01/31/dev-journal-1.org][Part 1]] contains the series index, while the [[https://gitlab.com/mavnn/caldance/-/commits/DevJournal4?ref_type=tags][DevJournal4]] tag for the CalDance project in GitLab holds the state of the repository as described here.
#+end_quote

So. We have an event store. Our website is going to have users. How do we go about user management?

** Where's the cheese?
:PROPERTIES:
:ID:       583CDD3C-46AB-4BE7-8F17-CD003D0ACF64
:END:

To borrow a term from domain driven design, this sounds like a "bounded context" within our system. Other parts of the code may care about certain events happening related to users (users being created, that kind of thing), but they probably shouldn't know or care about how the internals of "a user" work or what it takes to authenticate a user.

There are as many ways of organizing your code as there are grains of sand on the beach, but fundamentally all of the ones that help are about choosing where to have boundaries in your code base.

We are going to have three horizontal slices; shared library code, domain logic (our "business" code), and execution environment. Vertically we're going to slice the domain logic by bounded context - of which, admittedly, we only have one at the moment.

We end up with something like (things further down the table depend on the things above):

+--------------------------------------------------+
| Http Handler abstraction, UI components          |
+-------------------+------------------------------+
| User domain logic | Things users do domain logic |
+-------------------+------------------------------+
| Read configuration files, start the web server   |
+--------------------------------------------------+

You'll notice that this doesn't group the code by the technical task the code is trying to achieve, a pattern you'll often find in example project templates where you'll end up with a "Controllers" directory and a "Views" directory. It's also not an organization along "clean/hexagon/ports and adapters" lines with a strict demarcation between code that speaks to the outside world achieved via interfaces and abstractions.

It's not that I feel that either of those patterns has no merit (although I feel like the main driver of the first pattern is that you can suggest it even for projects you /know nothing about/ which is a useful property when writing templates and dispensing nuggets of wisdom at conferences about the *one true way* to organize code). But I do feel that for the vast majority of code bases, it is a far bigger gain to productivity to be able to co-locate code by /purpose/ than by /type/.

Let's face it: while you sometimes pick up a story/card/work ticket that requires you to go and change all the controllers (normally during dependency upgrades), or replace all the database interface implementations (you're about to have a long few months), it is much more likely on a day to day basis that you're trying to add a new field to the data we store about users, and you want to update the data store, business logic, and UI of /users/ to be able to do that. Taking this logic to its logical extremes leads you towards microservices - but that starts to bring in a different type of complexity of its own.

All of this to say: there's now a folder called ~Domain~ which holds our new, shiny, user management code in a file called: /drumroll, please/ ~User.fs~. Let's have a look at it in detail.

** The cheese. We have found it.
:PROPERTIES:
:ID:       367C9978-9C23-4455-8C85-330A944FC288
:END:

#+begin_src fsharp
  module Mavnn.CalDance.Domain.User

  open Falco
  open Falco.Routing
  open Falco.Markup
  open Falco.Security
  open Marten
  open Marten.Events.Aggregation
  open Marten.Events.Projections
  open Mavnn.CalDance
  open Mavnn.CalDance.Routing
  open System.Security.Claims
  open Microsoft.AspNetCore.Identity
#+end_src

As just mentioned, this module is going to be responsible of the whole vertical slice of the application for user management, so we start by including everything we need from the data store (~Marten~) through to the UI (~Falco.Markup~). We could have created sub modules within a Users folder if needed, but the module is only ~300 lines long so I haven't split it up (yet).

#+begin_src fsharp
  type User = { id: System.Guid; username: string }

  type UserState =
    | Active
    | Disabled

  [<CLIMutable>]
  type UserRecord =
    { Id: System.Guid
      Username: string
      PasswordHash: string
      State: UserState }

  type UserEvent =
    | Created of UserRecord
    | PasswordChanged of passwordHash: string
    | Disabled
#+end_src

Next we define a few data types that represent our users, and the events that can happen to them over time. This is important because we are "event sourcing" the state of our users, meaning that the golden source of truth for what state a user is in is defined by what events have happened to them so far. The two representations of the user represent what we care about in the running system (the main ~User~ type) and what we need to store about them on disk (the ~UserRecord~ type); in general we would expect that other modules /might/ make use of the ~User~ type but in general they should not make use of the ~UserRecord~ type. Its an open question in my mind whether it should actually be marked as a private type declaration, but I've erred on the side of leaving it available for now.

A minor implementation detail: to try and keep the incremental steps of the project manageable I'm using the default (de)serializers for Marten, which require the object to be deserialized from the data base has a default constructor and mutable fields, which we get from the ~[<CLIMutable>]~ attribute. We'll probably remove that going forwards by switching to a serialization strategy that works with immutable F# records.

The life cycle of our users is very simple at the moment; a ~Created~ event signals that a new, active, user was created. That user can change their password, or they can be marked disabled which effectively ends the lifecycle of the user. There's no way to reactivate a user now, although we could always add one later.

#+begin_src fsharp
  type UserRecordProjection() =
    inherit SingleStreamProjection<UserRecord>()

    member _.Create(userEvent, metadata: Events.IEvent) =
      match userEvent with
      | Created user -> user
      | _ ->
        // We should always receive a created event
        // first so this shouldn't ever happen...
        // ...but it might, and we don't want to throw
        // in projections.
        { Id = metadata.Id
          Username = ""
          PasswordHash = ""
          State = UserState.Disabled }


    member _.Apply(userEvent, userRecord: UserRecord) =
      task {

        match userEvent with
        | Created _ ->
          // Should never occur after the first event in the stream
          // so we ignore duplicates
          return userRecord
        | PasswordChanged passwordHash ->
          match userRecord with
          | { State = UserState.Disabled } ->
            // Don't update password of disabled users
            return userRecord
          | user ->
            return
              { user with
                  PasswordHash = passwordHash }
        | Disabled ->
          match userRecord with
          | { State = UserState.Disabled } ->
            return userRecord
          | { State = Active } ->
            return
              { userRecord with
                  State = UserState.Disabled }
      }
#+end_src

~Marten~ leans heavily into the code reflection capabilities of the dotnet framework, allowing us to configure our data store in terms of the in program types we want it to store. A "projection" in event sourcing is the logic which takes a list of events (our base line source of truth) and turns it into a current state, so this class defines a projection that will create and/or update ~UserRecord~ data in Marten's document store (we know it does this because it implements the ~SingleStreamProjection<UserRecord>~ interface). It will project /from/ events of the ~UserEvent~ type, because that is the type of the first argument of the ~Create~ and ~Apply~ methods we have supplied.

There are a few conventions we need to follow here to allow for this minimalist a configuration. Our current state type /must/ have an ~Id~ (or ~id~) field of type string, uuid, or integer. And when an event matching the signature of our projection is pushed to a stream with an ID, the resulting update to the current status type must produce a document with the same ID as the stream ID.

We're treating our records as immutable objects (because we're planning to make them immutable going forward), so our create and apply methods return a ~Task<UserRecord>~; if the document type was mutable we would also have the options of mutating it in place and returning void.

With that explanation out of the way, hopefully the state machine that represents our user life cycle is clear in the code above.

Now that we can store information about our users, and update them based on what is happening to them, it's time to start implementing the actual responsibilities of the module. We're keeping things minimal to get started, so we'll implement only the three things we /really/ need: sign up, log in, and log out.

#+begin_src fsharp
  type LoginFormData = { username: string; password: string }

  let findUserRecord (username: string) =
    Marten.withMarten (fun marten ->
      marten
        .Query<UserRecord>()
        .SingleOrDefaultAsync(fun ur ->
          ur.Username = username))
    |> Handler.map Marten.returnOption

  let loginRoute = RouteDef.literalSection "/login"
  let logoutRoute = RouteDef.literalSection "/logout"
  let signupRoute = RouteDef.literalSection "/signup"

  let getSessionUser: Handler<User option> =
    Handler.fromCtx (fun ctx ->
      match ctx.User with
      | null -> None
      | principal ->
        match
          (System.Guid.TryParse(
            principal.FindFirstValue("userId")
           ),
           principal.FindFirstValue("name"))
        with
        | ((false, _), _)
        | (_, null) -> None
        | ((true, id), username) ->
          Some { id = id; username = username })
#+end_src

A few definitions and helpers start us off; what data a form needs to capture for someone to sign up/log on, what urls exist and are managed by this module, and a couple of helper functions for obtaining a user record and a user session from the current HTTP context (using the ~Handler~ type we talked about in the last post).

#+begin_src fsharp
  let loginGetEndpoint =
    Handler.toEndpoint get loginRoute (fun () ->
      Handler.return' (
        Response.ofHtmlCsrf (fun csrfToken ->
          Elem.html
            []
            [ Elem.body
                []
                [ Elem.form
                    [ Attr.method "post" ]
                    [ Elem.input [ Attr.name "username" ]
                      Elem.input [ Attr.name "password" ]
                      Xss.antiforgeryInput csrfToken
                      Elem.input
                        [ Attr.type' "submit"
                          Attr.value "Submit" ] ] ] ])
      ))
#+end_src

Our first end point is straight forward. When we receive a get request to the login path, we reply with a form containing a token to prevent cross site vulnerabilities and username and password fields.

#+begin_src fsharp
  let private makePrincipal userRecord =
    let claims =
      [ new Claim("name", userRecord.Username)
        new Claim("userId", userRecord.Id.ToString()) ]

    let identity = new ClaimsIdentity(claims, "Cookies")

    new ClaimsPrincipal(identity)

  let passwordHasher = PasswordHasher()

  let updateUser (id: System.Guid, events: seq<UserEvent>) =
    handler {
      do!
        Marten.withMarten (fun marten ->
          task {
            // explicitly assign this as an array of objects
            // so that Marten chooses the correct method
            // overload for `Append`
            let eventObjs: obj[] =
              Array.ofSeq events |> Array.map box

            marten.Events.Append(id, eventObjs) |> ignore
            return! marten.SaveChangesAsync()
          })

      return!
        Marten.withMarten (fun marten ->
          marten.LoadAsync<UserRecord>(id))
    }
#+end_src

Our next end point is going to actually handle the form coming in, so it requires a few more helpers. The web framework we're using will handle things like sessions for us, but only if we "buy into" the .NET standard ways of representing a user, in this case using the ~ClaimsPrincipal~ type - so we have a helper to map from one of our user records to a claims principal. We initialize a password hasher which will salt and hash our passwords for us (don't roll your own crypto, folks, especially when your language ecosystem has a decent implementation ready for you). And finally we add an other method that works within our HTTP context expressions - ~updateUser~ takes the ID of a user and a list of events and returns the updated ~UserRecord~.

With all of that in place, we can write the ~loginPostEndpoint~.

#+begin_src fsharp
  let loginPostEndpoint =
    Handler.toEndpoint post loginRoute (fun () ->
      handler {
        let! loginData =
          Handler.formDataOrFail
            (Response.withStatusCode 400 >> Response.ofEmpty)
            (fun f ->
              Option.map2
                (fun username password ->
                  { username = username
                    password = password })
                (f.TryGetStringNonEmpty "username")
                (f.TryGetStringNonEmpty "password"))

        let! userRecord =
          findUserRecord loginData.username
          |> Handler.ofOption (
            Response.withStatusCode 403 >> Response.ofEmpty
          )

        let verificationResult =
          passwordHasher.VerifyHashedPassword(
            userRecord,
            userRecord.PasswordHash,
            loginData.password
          )

        match verificationResult with
        | PasswordVerificationResult.Failed ->
          return
            (Response.withStatusCode 403 >> Response.ofEmpty)
        | PasswordVerificationResult.Success ->
          return
            Response.signInAndRedirect
              "Cookies"
              (makePrincipal userRecord)
              "/"
        | PasswordVerificationResult.SuccessRehashNeeded ->
          let! _ =
            updateUser (
              userRecord.Id,
              [ PasswordChanged(
                  passwordHasher.HashPassword(
                    userRecord,
                    loginData.password
                  )
                ) ]
            )

          return
            Response.signInAndRedirect
              "Cookies"
              (makePrincipal userRecord)
              "/"
        | _ ->
          return
            failwithf
              "Unknown password verification result type %O"
              verificationResult

      })
#+end_src

Time to actually use our ~handler~ expression in earnest! There is some personal preference in play here, but personally I really like the clear flow of the request we can see happening in this code. We either have the form data we need, or we return a ~400~ error. Then we either find a user record with a matching username, or we return a ~403~ error (we don't want to reveal whether a username exists or not, so we return the same code as for when the password is incorrect; security +1, helpful error messages to users -1). Then we check the password, and we either return ~403~ (if it is wrong) or log you in if it is correct. A minor piece of extra complexity is introduced by the fact that the password hasher may signal that the password is correct but the /hash/ needs updating in storage, a background operation that the user does not need to know about.

I'll leave the other end points for the reader to read at their leisure [[https://gitlab.com/mavnn/caldance/-/blob/e62126228d63e77834112a193fcb0396f4410bc5/Server/src/Domain/User.fs][on Gitlab]], as they are either trivial (~logoutEndpoint~) or very similar to the log in end points (~signupGetEndpoint~ and ~signupPostEndpoint~).

Finally, we get to the end of the module where we export everything that the web server setup code (the bottom layer in my newly christened "sandwich with julienned domain" architecture).

#+begin_src fsharp
  let endpoints =
    [ loginGetEndpoint
      loginPostEndpoint
      logoutEndpoint
      signupGetEndpoint
      signupPostEndpoint ]

  let martenConfig (storeOptions: Marten.StoreOptions) =
    storeOptions.Projections.Add<UserRecordProjection>(
      ProjectionLifecycle.Inline
    )
#+end_src

At the moment, with only one domain, this is just an adhoc export of the points we're wanting to add to the webserver and the projections we want to add to ~Marten~. As the project grows, we'll probably add an interface that all domains will provide to allow for a standardized process for consuming the configuration. But there's little point trying to proactively create an abstraction over a single example of a pattern.

And there you have it; event sourced (basic) user management for our web application. If you have thoughts and questions, drop them as an issue on the [[https://gitlab.com/mavnn/caldance/-/blob/e62126228d63e77834112a193fcb0396f4410bc5/Server/src/Domain/User.fs][CalDance repository]]. I'd love to see example repositories having in depth discussions of when the architecture they suggest is or isn't useful, even if (especially if!) that discussion includes comments critical of the architecture demonstrated.

Next up: who knows? But probably a bit of testing and refactoring, our code is already a little messy in a few places.
* Log in, log out
:PROPERTIES:
:RSS_PERMALINK: 2024/03/01/dev_journal_4.html
:PUBDATE: 2024-03-01
:ID:       4BCEEFC0-677E-4744-BD20-2EFED4F3B805
:END:
#+begin_quote
This post is part of the "Dev Journal" series. [[file:../../../2024/01/31/dev-journal-1.org][Part 1]] contains the series index, while the [[https://gitlab.com/mavnn/caldance/-/commits/DevJournal4?ref_type=tags][DevJournal4]] tag for the CalDance project in GitLab holds the state of the repository as described here.
#+end_quote

This is the big one: we have our first piece of event sourcing, and a bunch of infrastructure to get us there. So big, in fact, that I'm going to split the post into two and publish the remainder early next week.

A lot has changed, and I'm not going to go into every single detail so if you're following along by hand I made a pull request for the changes added here so that you can [[https://gitlab.com/mavnn/caldance/-/merge_requests/2/diffs][see them all in one place]].

** Nix pulling its weight
:PROPERTIES:
:ID:       F10DDF0F-5702-481A-868D-32881EAB027D
:END:

We're about to add a database to our project, and this is an area where Nix really shines.

Adding services with pinned versions of dependencies to are development environment is as simple as adding them to the list in ~flake.nix~:

#+begin_src nix
  devShells.default = pkgs.mkShell {
    buildInputs = [
      dnc.sdk_8_0
      pkgs.nixfmt
      pkgs.skopeo
      pkgs.overmind
      pkgs.tmux
      pkgs.postgresql
      fantomas
      format-all
      format-stdin
      local_postgres
    ];
  };
#+end_src

The only clever thing we're doing here is also adding a ~local_postgres~ command which runs postgres with its data directory set to be a git ignored directory in the repository. This means that a simple git clean will reset the database along with everything else.

As a courtesy to developers who may work on code that isn't CalDance, we also set a non-standard port for postgres to use in our ~.envrc~ file so that we don't compete with any system wide installations that may already be running.

Overmind is a process runner that runs processes as defined in a ~Procfile~, so we add one to the root of the project with the following:

#+begin_src procfile
  server: dotnet watch --project Server/CalDance.Server.fsproj
  postgres: local_postgres
#+end_src

Now we can run ~overmind s~ to start both postgres and a dotnet watcher to live recompile our server code as it changes.

** Adding some nuget dependencies
:PROPERTIES:
:ID:       28BD40A2-CE8E-4A45-817D-9DAA3BCCD5B9
:END:

We're adding dependencies to our server of [[https://martendb.io/][Marten]] (document/event database library that sits on top of postgres) and [[https://serilog.net/][Serilog]] (a nice structured log library).

Marten depends on a postgres library with native (i.e. non-dotnet) dlls, so to allow Nix to cache and link to the correct versions of the native code we have to specify which runtimes we expect to be building our code for. For the curious minded, you don't need to do this to be able to run ~dotnet build~ directly because the ~dotnet~ cli will dynamically download and add the required native libraries - which breaks Nix's caching strategy of a reproducible output from a fixed set of input files.

This isn't a huge issue once you know you need to do it; you just add a ~RuntimeIdentifiers~ node to your project files under the ~TargetFramework~ node like so:

#+begin_src xml
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <RuntimeIdentifiers>osx-arm64;linux-x64;linux-arm64</RuntimeIdentifiers>
  </PropertyGroup>
#+end_src

Then we can add our nuget packages as normal and everything continues to work:

#+begin_src xml
  <ItemGroup>
    <PackageReference Include="Falco" Version="4.0.6" />
    <PackageReference Include="Marten" Version="6.4.1" />
    <PackageReference Include="Serilog" Version="3.1.1" />
    <PackageReference Include="Serilog.AspNetCore" Version="8.0.1" />
    <PackageReference Include="Serilog.Sinks.Console" Version="5.0.1" />
  </ItemGroup>
#+end_src

** Opinionated endpoint builders
:PROPERTIES:
:ID:       2206CECB-D623-43F8-BBDA-0A3269C2C739
:END:

In general, the code to handle an endpoint in an AspNet.Core application is a function from ~HttpContext~ to ~Task~, where we mutate the HTTP context and then write the correct output stream.

Falco gives us an abstraction a little higher than that by giving us a set of composable functions for manipulating the HTTP context, which is already a step forward. But I was finding them harder to compose than I would like because in several cases the functions took two inputs and effectively "branched" the response that could be given - for example, do I have the form fields I expect in this POST request, or am I logged in.

I quickly realized that I'd be happier with some kind of "result" mechanism - a way to be able to declare during the specification of a handler that I wanted to short circuit from this point onwards with a failure response.

I also knew that I wanted a type safe way of writing handlers for paths with "place holder" sections.

Because of that, I added a ~Routing~ module in which I've defined a ~Handler~ type as below:

#+begin_src fsharp
  type Handler<'a> =
    HttpContext -> Task<HttpContext * Result<'a, HttpHandler>>
#+end_src

For the sharp eyed among you with functional programming experience you may have spotted this is the same shape as the monad type of a stateful either monad, and indeed we also define a computational expression called ~handler~ that allows us to now write our handlers in a more declarative style.

The revised ~indexEndpoint~ in the main program file gives a good example of what it looks like:

#+begin_src fsharp
  let indexRoute = literalSection "/"

  let indexEndpoint =
    Handler.toEndpoint get indexRoute (fun () ->
      handler {
        let! user = User.getSessionUser

        return
          (Response.ofHtml (
            Elem.html
              []
              [ Elem.body
                  []
                  [ Elem.h1
                      []
                      [ match user with
                        | Some u ->
                          Text.raw $"Hi {u.username}!"
                        | None ->
                          Text.raw "You should go log in!" ]
                    Elem.p
                      []
                      [ Text.raw "Would you like to "
                        Elem.a
                          [ Attr.href (
                              greetingRoute.link "Bob"
                            ) ]
                          [ Text.raw "greet Bob?" ] ] ] ]
          ))
      })
#+end_src

Note the ~let!~ on the first line where we pull the user session out of the HTTP context which the computational expression is "invisibly" carrying along for us.

** Connecting up the database
:PROPERTIES:
:ID:       11782DF9-48EB-4E90-89DC-4082F58117DD
:END:

Having defined our handler type, it makes sense to make the rest of our tooling easy to use from within the abstraction.

The new ~Marten~ module contains some boiler plate to configure Marten and add Serilog logging to it, but most importantly it also adds:

#+begin_src fsharp
  let withMarten f =
    Handler.fromCtx (fun ctx ->
      ctx.GetService<IDocumentSession>())
    |> Handler.bind (f >> Handler.returnTask)

  // Marten returns null if a record isn't found, but
  // F# records declare they can't be null. This works
  // around that to return an option instead
  let returnOption v =
    if (v |> box |> isNull) then None else Some v
#+end_src

Now from within any HTTP handler we're writing, we can write code like:

#+begin_src fsharp
  let! user =
    Marten.withMarten (fun marten ->
      marten.LoadAsync<UserRecord>(id))
#+end_src

...and as if by magic the request specific Marten session will be pulled out of the HTTP context of the request and we can use it to connect to our data source.

** To be continued...
:PROPERTIES:
:ID:       7A23AE2D-82CE-44FF-95F5-8062C5A8DA49
:END:

I think that's about enough for this blog post, because I want to leave a whole post for the real meat of this set of changes: our first domain entity, the ~User~.

If you want a sneak peak, you can check out the PR and see how we can define a neat vertical slice of responsibility in our code base. The module takes the responsibility for user management all the way from the domain object, the events that can happen to it, the Marten config to make sure those are tracked, through to the paths that it has responsibility for and the UI that will be displayed when they are requested. Lots of fun stuff for us to talk about in the next exciting installment of "Dev Journal": different time, multiple channels, next week.

Next up: [[file:../../../2024/03/05/dev_journal_4_2.org][Log in, log out (part 2)]]
* ADHD and TDD
:PROPERTIES:
:RSS_PERMALINK: 2024/02/21/adhd_and_tdd.html
:PUBDATE: 2024-02-21
:ID:       42217FB5-364A-46B2-8C78-36631B5B5245
:END:
#+begin_quote
This piece of writing started as repost comment on LinkedIn responding to a question from J. B. Rainsberger about [[https://www.linkedin.com/posts/jbrains_tdd-adhd-adhd-activity-7165713710492176385-xK56][how people with an ADHD diagnosis experienced TDD]]. It's a good question, but it's the kind of topic I "own" enough that I don't want to leave my thoughts on it locked away on a platform like LinkedIn, so now they're here too!
#+end_quote

This is an interesting one for me; I have both an ADHD diagnosis and I do feel that I use certain programming practices to compensate for it. Something that interests me enough that I'm talking on the subject at Lambda Days 2024, in fact.

Any practice that starts with building a feed back loop is going to be helpful from the ADHD point of view; for example, I have a strong preference for strongly typed languages because the compiler will remind me to finish bits I've forgotten about or catch the typos of concentration lapses in the wild.

That said, I'm personally not a huge fan of TDD as I've normally met it in the wild (I can see the one true Scotsman replies from here, and some of you are probably even right). And the reason for that dislike is also ADHD related but has nothing to do with the initial writing of the code - but with refactoring.

In the vast majority of cases I've seen, TDD has led to code bases with many, many, tests that are tightly coupled to the current implementation of a piece of code because what's actually happened is that each test has been written to confirm the next piece of the implementation is doing what is expected, not to test the overall inputs/outputs of the "block". Mocks that check they are called in a certain order or with certain inputs. Carefully crafted fake dependencies which return the data needed in the correct order and type to satisfy the internal of the function being tested. (Is this what TDD is meant to be? No, not at all - I'm aware)

This makes refactoring deeply painful with a pain that hits hard at the heart of ADHD - you're faced with the choice of updating all these painful, pointless, implementation internal specific mocks on the one hand or having the argument about why your refactoring PR "reduces test coverage" on the other. If you're particularly unlucky there aren't any tests covering the actual _behaviour_ of the original code at all, and now you're left wondering:

"But is my refactor really a refactor at all?"

(It would be remiss of me not to note that teaching developers how to test behaviour and not implementations is actually a service I offer, partly because I don't want to live with the consequences of them not knowing! See [[file:../../../2024/01/29/short_term_help.org][my short term consulting page]].)
* Does it run? Dev Journal 3
:PROPERTIES:
:RSS_PERMALINK: 2024/02/20/dev-journal-3.html
:PUBDATE: 2024-02-20
:ID:       F9033D00-8C8C-4AB4-8637-9F913480C172
:END:
#+begin_quote
This post is part of the "Dev Journal" series. [[file:../../../2024/01/31/dev-journal-1.org][Part 1]] contains the series index, while the [[https://gitlab.com/mavnn/caldance/-/commits/DevJournal3?ref_type=tags][DevJournal3]] tag for the CalDance project in GitLab holds the state of the repository as described here.
#+end_quote

A short update this time. [[https://gitlab.com/mavnn/caldance/-/issues/3][Gregg Bremer]] (hi Gregg!) pointed out that running ~nix run~ on his linux machine resulted in an error about not being able to find ~libssl~.

This neatly highlights one of the weak spots of Nix; while an excellent packaging solution, it isn't perfect. Nix sandboxes your packages by altering the path environment variable, but not everything is located via that mechanism.

In this case, ~nix run~ ran on my machine because I happened to have the libraries in the "right place" for a self contained dotnet core executable, but Gregg did not.

Neither, it turns out, did the docker container I was building. I built and tested it initially with a dotnet console app (which did work, not needing ~libssl~) and then carried on assuming that running ~nix run~ on my local machine would also tell me if the docker image could run correctly.

I've now fixed up the code in the previous posts (we needed to add some ~runtimeDeps~ to our server package, and the docker image start up command needs to create a writable ~/tmp~ directory for asp.net to run correctly).

Most importantly though, I've also made sure that CI will prevent this from happening again by actually checking that the docker image produced can respond to a request to the index with a 200 response code. This is done by adding "stages" to our CI build; the first does exactly what we were doing already, the second then starts the just finished docker image as a "service" and uses ~curl~ to check it can respond to us.

You can check out the revised ~.gitlab-ci.yml~ file below:

#+begin_src yaml
  stages:
    - build-container
    - end-to-end-tests

  build-container:
    stage: build-container
    image:
      name: "nixos/nix:2.19.3"
    variables:
      IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
    before_script:
      - nix-env --install --attr nixpkgs.skopeo
    script:
      - mkdir -p "$HOME/.config/nix"
      - echo 'experimental-features = nix-command flakes' > "$HOME/.config/nix/nix.conf"
      - mkdir -p "/etc/containers/"
      - echo '{"default":[{"type":"insecureAcceptAnything"}]}' > /etc/containers/policy.json
      - skopeo login --username "$CI_REGISTRY_USER" --password "$CI_REGISTRY_PASSWORD" "$CI_REGISTRY"
      - 'nix build .#dockerImage .#test'
      - mkdir testResults
      - 'cp result-1/* testResults'
      - ls -lh ./result
      - 'skopeo inspect docker-archive://$(readlink -f ./result)'
      - 'skopeo copy docker-archive://$(readlink -f ./result) docker://$IMAGE_TAG'
    artifacts:
      when: always
      paths:
        - 'testResults/*.xml'
      reports:
        junit: 'testResults/*.xml'

  end-to-end-tests:
    stage: end-to-end-tests
    image:
      name: "nixos/nix:2.19.3"
    variables:
      IMAGE_TAG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG
      GIT_STRATEGY: none
    services:
      - name: $IMAGE_TAG
        alias: caldance
    script:
      - curl -f "http://caldance:5001/"
#+end_src
