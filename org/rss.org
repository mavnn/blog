#+TITLE: Mavnn's blog

* Do notation for TypeScript
:PROPERTIES:
:RSS_PERMALINK: 2024/02/19/do-notation-for-typescript.html
:PUBDATE: 2024-02-19
:ID:       47EC6E0A-88F2-4453-9080-92A8417DBE19
:END:
This is rather an aside from recent blog posts, but something I found interesting none the less.

Fair warning to start us off: this post assumes that you are aware of and understand "do notation" (or "computational expressions" or "monad syntax") and like the idea of having it available in TypeScript.

It starts by working through a possible way of implementing a type safe representation of a sequence of monadic operations that has a much nicer user experience than nested continuation functions, and then leads into a length example of both building and showing how to use a monad which I've found very useful when working in TypeScript for handling asynchronous code that needs to meaningfully respond to both successes and failures.

The idea is that we're going to go from code that looks like this:

#+begin_src typescript
  export const processLaxCallback = ({
    laxOperations,
    commands,
    localFunctions,
  }: LaxCallbackDependencies) => async (httpRequest) => {
    try {
      const laxSignatureCheck = await laxOperations.checkSignature(httpRequest)
      if(isFailure(signature)) {
        await reportError(signature)
        return
      }
      const laxContext = laxOperations.parseRequest({ httpRequest, laxSignatureCheck })
      if(isFailure(laxContext)) {
        await reportError(laxContext)
        return
      }
      // ...continued
    } catch (e) {
      // ... etc
    }
  }
#+end_src

...to code that looks more like this:

#+begin_src typescript
  export const processLaxCallback = ({
    laxOperations,
    commands,
    localFunctions,
  }: LaxCallbackDependencies) =>
    SolidChain.start<{ httpRequest: HttpRequest }, LaxCallBackState>()
      .chain("laxSignatureCheck", laxOperations.checkSignature)
      .chain("laxContext", laxOperations.parseRequest)
      // ...continued
#+end_src

If you're impatient you can jump straight to [[*Appendix 2: A slightly excessive example of the Solid monad in action][appendix 2]] where you will find a cut and pastable code block with everything you need to play with the code in the TypeScript editor of your choice.

For the avoidance of any doubt, all the code in this blog post is available for re-use under the MIT license as list in [[*Appendix 3: license][appendix 3]].

** The idea
:PROPERTIES:
:ID:       D5F2E2D6-ED4C-4433-B423-CA154BC6EC22
:END:

TypeScript has one form of monad notation already - the ~await~ keyword. Unfortunately, there isn't any way to plug into the mechanism used and define your own alternative ~bind~ implementation without doing something dangerously hacky. And, frankly, the last thing your TypeScript code needs is an other sharp edge to cut yourself on.

But... what does binding a value in monad notation really do? It doesn't allow you to write code you couldn't have written anyway long hand. It allows you to give the result of a calculation in your code in name in the current scope.

So: if we consider the fact that a scope is really just a mapping from names to values, and that TypeScript allows function inputs to alter the type of their output... maybe we can do something with that?

** Defining a scope
:PROPERTIES:
:ID:       24A4229A-D1E1-42BD-89C6-55EB5E271B09
:END:

A type that maps names to values is reasonably easy to define in TypeScript. It looks something like this:

#+begin_src typescript
  export type Scope<Keys extends string> = {
    [K in Keys]: any;
  };
#+end_src

We can say that anything we're willing to consider as a scope is a type that extends the type above: it will have some keys, which will all be strings, and they will map to some values, which will all be sub types of ~any~.

Now we need a type safe way to add a value to the scope.

We start with a calculated type which works out what the result of adding a value with a name to a scope should be:

#+begin_src typescript
  export type ExtendedScope<
    OldScope extends Scope<any>,
    NewField extends string,
    NewValue
  > = OldScope extends any
    ? {
        [K in keyof OldScope | NewField]: K extends NewField
          ? NewValue
          : K extends keyof OldScope
          ? OldScope[K]
          : never;
      }
    : never;
#+end_src

