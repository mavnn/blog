#+TITLE: Mavnn's blog

* Writing CVs for more senior roles
:PROPERTIES:
:RSS_PERMALINK: 2024/01/26/writing_a_cv.html
:PUBDATE: 2024-01-26
:ID:       AE4D8274-76C3-4DF9-971A-7E95BEB11952
:END:
A while back (/checks notes, gulps/) I wrote a fairly successful [[https://blog.mavnn.co.uk/good-developer-cvs/][blog post on the types of CVs]] I liked receiving as one of the people screening technical applications, and some of the mistakes I was seeing applicants making.

What I didn't speak about at all was the "structure" of the CV; how to arrange it, and what sections to include/not include.

Today somebody asked me for an actual CV for the first time in... quite a while actually. The last couple of jobs both had their own interview process that didn't include one, so that means it's been at least 5 years.

Turns out that having been on the other side of the table a few more times now, and hiring for more senior candidates, my CV creation style has changed radically. The result is four broad categories of ways I've been effective in previous jobs, with a brief description of when I became senior enough to start doing that. So rather than having a big timeline of work history and education, I end up with things like:

#+begin_quote
*Training and mentoring*

For over a decade I have provided mentoring and training both to team members and as a service offered. This has ranged from people learning to code for the first time (CodeInstitute), to week long courses teaching professional developers new programming languages or architectural styles (@mavnn ltd), to giving talks at conferences on topics from the obscure to the philosophical (SDDConf, NDC, F# Exchange, Lambda Days, etc).

Apart from formal training I have mentored teams several times during the introduction of new programming languages, libraries, and techniques (15below, NoRedInk, Blissfully/Vendr).
#+end_quote

Again - your mileage may vary; it's not like I've had any feed back on the application yet, or even that a single response tells you much about how the CV be received in general. But I can tell you that from the other side of the table that I'm much more interested in what *you* think are the areas you've made a difference, or that you're proud of, than I am in the job descriptions of your last 5 posts and where you went to secondary school.

One slight caveat: I did include my LinkedIn profile, which has all the gritty dates and things. It just wasn't what I chose to highlight in the part of the process that I can control. Your CV is your chance to control the narrative - take it.
* TypeScript Enums and Serialization
:PROPERTIES:
:RSS_PERMALINK: 2022/11/24/typescript_enums_and_serialization.html
:PUBDATE: 2024-01-24
:ID:       A34C4E15-A416-42BE-9B5B-B27BC7064FCF
:END:
#+index: TypeScript!Deserializing enums safely

In general, TypeScript is [[file:../../../2022/01/07/types-in-typescript.org][not its own language]] - it's a set of annotations that
can be added to JavaScript to help check the "correctness" of you program. The
authors have been very reluctant to add features to TypeScript that don't exist
in JavaScript, and so normally you can turn your TypeScript into JavaScript purely
by /deleting/ the type annotations that you've added.

Enums, though, are a bit different. They actually generate JavaScript code based on
the TypeScript you write. Today, we're going to look at a piece of code that allows
you to deserialize enums with string values in a type safe manner. And we're going
to take advantage of the fact that enums (according to the TypeScript compiler) are
both a type, and a value with a different type - at the same time.

For context, we're going to be using [[https://www.npmjs.com/package/schemawax][SchemaWax]] to create our decoder, so we can
build it into a larger contextual decoder as needed.

First: the code! If you already know SchemaWax, you don't care about types, and
you're here because it was a hit for "deserialize any enum" on Google this is
the bit to cut and paste.

#+begin_src typescript
  import * as D from "schemawax"

  // This is only type safe if passed a Enum with string values.
  // I don't think there's anyway to stop someone passing { "boo": "broken" }
  // in TypeScripts type system :(
  // At least this stops us from rewriting the same unsafe code every time though.
  export const stringEnumDecoder = <Enum extends { [name: string]: string }>(
    targetEnum: Enum,
  ): D.Decoder<Enum[keyof Enum]> => D.literalUnion(...Object.values(targetEnum)) as D.Decoder<Enum[keyof Enum]>
#+end_src

That's it. The whole thing. How do you use it?

Like this:

#+begin_src typescript
  import * as D from "schemawax"
  import { stringEnumDecoder } from "./enum"

  enum TestEnum1 {
    "why" = "would",
    "anyone" = "do",
    "this" = "!",
  }

  type ObjectWithEnumField = {
    testEnum: TestEnum1
    name: string
    age?: number
  }

  describe("stringEnumDecoder", () => {
    it("decodes string enums", () => {
      const result = stringEnumDecoder(TestEnum1).forceDecode("!")
      expect(result).toEqual(TestEnum1.this)
    })
    it("rejects invalid enum values", () => {
      const result = stringEnumDecoder(TestEnum1).decode("this")
      expect(result).toBeNull()
    })

    it("can be used in larger decoders", () => {
      const objectDecoder: D.Decoder<ObjectWithEnumField> = D.object({
        required: {
          testEnum: stringEnumDecoder(TestEnum1),
          name: D.string,
        },
        optional: {
          dateOfBirth: D.string.andThen((str) => new Date(str)),
        },
      })

      const inputFromApi = `{ "testEnum": "!", "name": "bob", "dateOfBirth": "2022-11-24"}`
      const result1 = objectDecoder.decode(JSON.parse(inputFromApi))
      expect(result1).toEqual({ testEnum: TestEnum1.this, name: "bob", dateOfBirth: new Date("2022-11-24") })
    })
  })
#+end_src

How does this work? How can we write a function that can take an enum type as an
argument, and then generate a decoder? (Feel free to drop out if you were just
here to solve your immediate problem!)

If you type an enum into the online TypeScript playground ([[https://www.typescriptlang.org/play?#code/KYOwrgtgBAYg9nKBvAUFKB5EwoF4oBEc2BANGlACoDui+BALrWSgL4pA][here's one I prepared
earlier]]), you'll see that the enum (with string values) is, in fact, compiled
into a variable that ends up with a simple record with string keys and values
attached to it.

Going back to the implementation, you'll see that's exactly the constraint on
the argument we pass into ~stringEnumDecoder~.

#+begin_src typescript
  ...
  export const stringEnumDecoder = <Enum extends { [name: string]: string }>(... rest of implementation)
#+end_src

Then some slightly weird magic happens: when you pass an enum into the function,
the TypeScript compiler infers that the type of the argument is the ~typeof~ the
enum you passed in. Whatever is happening internally here, it keeps track of the
fact that the keys of this type are the types of the valid enum cases, so it
turns ~Enum[keyof Enum]~ into the union type of each of the possible enum value
types which is, if you squint hard enough, actually the enum itself. We then
return a decoder that accepts a string, checks that said string is actually one
of the /values/ stored in the enum object, and then tells the compiler that this
decoder will only ever return valid enum values. Unfortunately with a cast - but
the full context we need to check this cast is valid is contained within this
one line of code.

So there you have it: a safe way to deserialize strings into enums, and it even
composes nicely into more complex decoders.

Until next time!

Want to comment on something you've read here? [[https://mastodon.sdf.org/@mavnn/109400451463740531][This mastodon post]] is the
official commenting point!
* ADHD and me
:PROPERTIES:
:RSS_PERMALINK: 2022/10/14/adhd_and_me.html
:PUBDATE: 2022-10-14
:ID:       7E3B9E08-5F7E-4674-A310-5B313913DC2C
:END:
This morning, I did the washing up.

Now: your first response might be "Michael: why do I care? Do I look like a
washing up blog reader?"

But that would miss the point. This morning I did the washing up, and only the
washing up. I didn't procrastinate with some Twitter or YouTube videos first. I
didn't need to listen to a podcast at the same time to avoid getting lost
staring off into space thinking about something completely different.

Most importantly: no crushing feeling of overwhelm about needing to do this task
that both feels insurmountable but is obviously (objectively) trivial. It's
embarrassing to admit that I've been repeatedly reduced to tears by the need to
do the washing up.

This change, it appears, is the impact of methylphenidate (Ritalin®) on my
brain. I was recently diagnosed with ADHD, and yesterday I undertook a series of
"challenge tests" to see if I am one of the [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2732009/][75% of adult's with ADHD whose
symptoms are helped by the drug]].

I did the same series of tests twice: once in the morning, before taking
methylphenidate; the other in the afternoon an hour after taking the first trial
intake under observation (methylphenidate is a controlled substance here in
Italy).

It was a strange, and almost disturbing, experience to feel my brain acting
differently. Recall was smoother. Free association on a topic easier because my
brain stayed on /that/ topic, without veering away onto side lines that I needed
to filter out from what I was saying. My thoughts were still my own, but
with... less in the way.

You see: trying to do stuff (and by stuff I mean pretty much /anything/ that you
need to choose to do, rather than that you happen to start because it distracted
you...) with ADHD is hard. I didn't realize how hard until some of that effort
was lifted.

The closest I've come to being able to describe it is that having ADHD is like
your brain wearing an ancient near eastern tunic to work a farm.

Ever hear the phrase "gird your loins"? It's the [[https://www.artofmanliness.com/skills/manly-know-how/how-to-gird-up-your-loins-an-illustrated-guide/][process of tying up your tunic]]
(designed primarily to keep you cool) so that you can run, or fight, or carry
out hard physical labour at ground level without the 'skirt' of the tunic
getting in the way and tripping you up.

My brain wears a tunic: I need to put effort into preparing to do things before
I can even start doing them. So it takes energy and effort just to /get ready to
start/. And if you make a mistake in the girding, or the knot slips? Well, now
you're half way through your task with a bunch of cloth swishing around your
legs and getting in the way.

Methylphenidate is the equivalent of putting on jeans.[fn:1] You can be casual still,
but you can also just... do stuff? Finish your morning coffee, look across the
kitchen, and go: "I need to do the washing up."

This morning, I did the washing up.

[fn:1] Very short lived jeans, at the moment. While slow release versions are
available, the version of methylphenidate used while experimenting to find the
ideal personal dose has an effect period of about 4-6 hours at the outside and
I'm only prescribed one dose a day. So I still get to wear a brain tunic in the
afternoons until I reach a stable enough dosage to take the slow release
version.
* Teaching (coding) wisdom
:PROPERTIES:
:RSS_PERMALINK: 2022/06/20/teaching-coding-wisdom.html
:PUBDATE: 2022-06-20
:ID:       F8145816-EEC2-42D1-8B41-D75C9029B443
:END:
#+begin_quote
[talking about the teaching of wisdom]

There are these distillations that we get throughout the story, like in the ten commandments or in the Sermon on the Mount. At points, it’s very clear: “Don’t murder.” “Honor your ma and pa.” “Do to others what you want them to do to you.” But if you really think about it, you don’t want a list. You might want a list for a certain season that will train your moral compass. Then, when you confront really complex situations, like Joshua or Moses, and it’s not clear, and there’s no list, you’ve been shaped to be the kind of person who knows how to figure out the right way forward. Lists will not help you do that. Wisdom will help you do that.

--- https://bibleproject.com/podcast/wisdom-lifes-complexity/
#+end_quote

Listening to the podcast above earlier and thinking that it feels very similar to how to teach good coding practices. We use the short hand of rules, and lists of recommendations… sometimes. But that doesn’t teach you how to deal with the complex situations, the edge cases, the actual real problems that need solving.

The flip side being that as soon as you’re guided by wisdom, by the stories of what works, the shaping of thinking, you start getting into interpretation and ambiguity because you’re actually needing to think about the decisions you’re making. It can become hard to explain why you’re doing things, and different experiences will have coloured the “wisdom” that you’ve formed over the years. Which is why it becomes so important to have a variety of backgrounds and a willingness to communicate in a technical team that’s actually going to get things done. Why the lists and rules (microservices rule the world! TDD is the one true way! pure code is the only real code!) only get you so far, and should be starting points - not ending points.

If you'd like to comment on this post, or suggest a correction, you can [[https://github.com/mavnn/blog/blob/master/2022/06/20/teaching-coding-wisdom.org][submit suggestions for changes]] (GitHub account required). Just hit the "edit this file button" and go from there - or log an issue on the repository.
