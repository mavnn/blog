#+TITLE: Mavnn's blog

* Conflict free syncthing notes
:PROPERTIES:
:ID:       0C23E268-F37F-4C6C-8E38-F04C03486EED
:RSS_PERMALINK: 2025/08/15/conflict_free_syncthing_notes.html
:PUBDATE:  2025-08-15
:END:
Just a short trick this time, mostly for my own records. As a family we've started moving to Syncthing for syncing files across devices, and "open" note taking formats like ".org" and ".md" for long term note taking. I've been using org-mode for a while personally, and now the rest of the family have been burned enough by the alternatives over the years that they're coming to similar conclusions even if not all of them want to use Emacs!

Syncthing has a sensible general purpose policy with conflicts of creating a copy of a file where a conflict exists with a ~.sync-conflict-<date>-<time>-<device-id>.~ pseudo-extension added before the files true extension (or to the end of the filename if it didn't have one).

In general, this is great as it means that a) all in sync devices have a shared understanding of the "winning" version of the file, and b) you can manually do any comparisons you need to and by saving a new version of the "original" file name and deleting the conflicting copies you resolve the conflict for everybody.

But with plain text note files, we can actually do a bit better than that. Because these files are always text, we can use a standard merge algorithm on them. And because the places where conflicts happen most are (almost by definition) things like todo lists and similar, we can even go a step further and specify that even if there is a line/word level conflict that the algorithm can't resolve, we can allow the resolution to be "just in line the changes from both sides."

So there's now a cron job running on the Raspberry Pi that acts as our "introducer" node in our Syncthing mesh, which looks like this:

#+begin_src bash
  #!/usr/bin/env bash
  # Find all files that are syncthing conflict markers, and have
  # a "note" extension (md or txt or org)
  readarray -t CONFLICTS < <( \
    find /syncthing/share/parent/directory -type f \
         -name "*.sync-conflict*" \
         \( -name "*.md" -o -name "*.org" -o -name "*.txt" \) \
  )
  # For each file:
  for CONFLICT in "${CONFLICTS[@]}";
  do
     # Build the regex for matching conflict files and extracting
     # the original file name.
     # 1. The marker, capturing the file name in a group.
     REG="\(.*\)sync-conflict-"
     # 2. The date
     REG+="[[:digit:]]\{8\}-"
     # 3. The time
     REG+="[[:digit:]]\{6\}-"
     # 4. The originating device ID
     REG+="[A-Z0-9]\{7\}"
     # 5. The original file extension
     REG+=".\(.*\)"
     # Find the "winning" version with the original file name
     CHOSEN="$(echo "$CONFLICT" | sed -n "s/${REG}/\1\2/p" )"
     echo Merging "$CHOSEN" "$CONFLICT"
     # If the original file actually exists (nothing stops a user from deleting it)
     if [ -f "$CHOSEN" ]; then
       # Merge the two versions of the file, taking from both in case of conflict;
       # this may cause repetition but won't lose data. Delete the conflict file
       # but only if the merge reported no errors.
       git merge-file --union \
           "$CHOSEN" "/syncthing/share/parent/directory/empty_file" \
           "$CONFLICT" && rm "$CONFLICT"
     else
       echo "No current file found"
     fi
  done
#+end_src

The only slight gotcha is you'll need to run ~touch /syncthing/share/parent/directory/empty_file~ to create an empty file to be used as the "parent" of the two conflicting versions. Extra internet points available to anyone who instead works out how to use a historical version from syncthing's archive functionality, but for me on this occasion that wasn't really needed.

Got comments or ideas? The Mastodon post for this blog can be found here: https://mastodon.sdf.org/@mavnn/115038110993820603
* A gentle introduction to Effect TS
:PROPERTIES:
:ID:       897A1F78-39B6-4704-AF2F-2A774F9B1F72
:RSS_PERMALINK: 2024/09/16/intro_to_effect_ts.html
:PUBDATE:  2024-09-16
:END:
I've recently been writing TypeScript again in a green field project, and we made the decision to
use the [[https://effect.website/][Effect]] library. It's not a small decision to make: although you can use bits of Effect in
an existing code base, its real benefit is when it is used as (to quote the website) "the missing
standard library for TypeScript".

Overall, we're happy with the choice but the learning curve has a few sharp edges and while the
[[https://effect.website/docs/introduction][docs]] aren't bad it does feel like they could do a better job of introducing the most used features
in a way that feels familiar to TypeScript developers so they can at least *read existing* Effect
code before starting to introduce the many, many, powerful features that come with the library.

This post is an attempt to do exactly that.

** The Effect type
:PROPERTIES:
:ID:       270ECBCE-6867-4853-9587-DF705E732BFD
:END:

The very first thing you need to understand about Effect is that it is built around a specific type.
Appropriately enough, the ~Effect~ type. This type functions as a replacement for ~Promise~, allowing
for asynchronous code, but also covers a few other needs.

Let's get started, in the traditional way:

#+begin_src typescript
  import { Effect } from "effect"

  const hello = (name?: string): Effect.Effect<string> =>
    Effect.gen(function* () {
      return `Hello, ${name || "world"}!`
    })
#+end_src

This code is spiritually the same as writing:

#+begin_src typescript
  const helloAsync = async (name?: string): Promise<string> => {
    return `Hello, ${name || "world"}!`
  }
#+end_src

You can think of the ~Effect.gen(function* () { ... })~ as a slightly more verbose version of the ~async~ prefix to a function.

What about calling the function? Again, we have a similar concept but different syntax to ~async/await~.

#+begin_src typescript
  // Effect version
  const sayHello: Effect.Effect<void> =
    Effect.gen(function* () {
      const greeting = yield* hello("world")
      yield* sendGreetings(greeting)
    })

  // Async/await version
  const sayHelloAsync: Promise<void> = {
    const greeting = await helloAsync("world")
    await sendGreetingsAsync(greeting)
  }
#+end_src

Given that we're using a cooperative scheduling system for asynchronous code, you can think of ~yield*~ as
saying "hey runtime - I'm yielding the thread now, start me back up when the effect on the right has finished."

There is, however one big difference between these two which will catch you out if you don't know about it.

** Hot and cold promises
:PROPERTIES:
:ID:       F2A23C50-3555-4D45-ACE3-41ACB5901919
:END:

~Promise~ is what is sometimes referred to as a "hot" or "immediate" asynchronous construct. What does that mean?

Well, in the example above ~sayHelloAsync~ is a constant value. As soon as the value is created, the logic within
the promise will be scheduled for execution and we will start the process of asynchronously running the ~helloAsync~
function. If we await the result of ~sayHelloAsync~ somewhere else, we will block until the function has finished.

This also means that if we ~await~ ~sayHelloAsync~ in two different places, we will only send greetings *once*. After
all, the ~Promise~ type that we are handing around represents the running execution of an asynchronous process; it has
already started, and awaiting it multiple times won't start it again.

~Effect~, by contrast, is a "cold" or "thunked" asynchronous construct. It represents a series of steps that /will be/
executed /if/ the result is requested.

So if we run:

#+begin_src typescript
  const camelot: Effect.Effect<void> =
    Effect.gen(function* () {
      yield* sayHello
      yield* sayHello
      yield* sayHello
    })
#+end_src

We will send the greetings three times, but only when somebody requests the result of running ~camelot~. Until
then, nothing will happen at all.

*If you remember nothing else from this post*, remember that an ~Effect~ that nobody executes never runs. This /will/ catch you
out with logging.

#+begin_src typescript
  // logs nothing
  const camelot: Effect.Effect<void> =
    Effect.gen(function* () {
      Effect.log("Bass voice: spam a looooooot")
      yield* sayHello
      yield* sayHello
      yield* sayHello
    })

  // logs the bass voice
  const camelot: Effect.Effect<void> =
    Effect.gen(function* () {
      yield* Effect.log("Bass voice: spam a looooooot")
      yield* sayHello
      yield* sayHello
      yield* sayHello
    })
#+end_src

Although the ability to create Effects without executing them can be extremely useful, leaving ~yield*~ out of
your code when you actually need it is probably the most frustrating element of learning Effect, and the one
that the compiler is least able to warn you about.

** Pipes
:PROPERTIES:
:ID:       9A5D6F4A-FACD-4AEC-A8FE-01F7C5B5220D
:END:

Effect makes heavy usage of a concept it calls "pipes", which is a way of passing a value through a series of functions.

The main place you'll see this is that we can wrap ~Effect~ values in a wide variety of ways. These are very powerful,
but quickly start suffering from the "lisp effect" of a pyramid of brackets when we start combining them.

Let's rewrite the ~camelot~ function above using the built in ~Effect.repeatN~ method:

