#+TITLE: Mavnn's blog

* TypeScript Enums and Serialization
:PROPERTIES:
:RSS_PERMALINK: 2022/11/24/typescript_enums_and_serialization.html
:PUBDATE: 2022-11-24
:ID:       528A5FA5-DC62-403A-9379-336ABFBDB014
:END:
#+index: TypeScript!Deserializing enums safely

In general, TypeScript is [[file:../../../2022/01/07/types-in-typescript.org][not its own language]] - it's a set of annotations that
can be added to JavaScript to help check the "correctness" of you program. The
authors have been very reluctant to add features to TypeScript that don't exist
in JavaScript, and so normally you can turn your TypeScript into JavaScript purely
by /deleting/ the type annotations that you've added.

Enums, though, are a bit different. They actually generate JavaScript code based on
the TypeScript you write. Today, we're going to look at a piece of code that allows
you to deserialize enums with string values in a type safe manner. And we're going
to take advantage of the fact that enums (according to the TypeScript compiler) are
both a type, and a value with a different type - at the same time.

For context, we're going to be using [[https://www.npmjs.com/package/schemawax][SchemaWax]] to create our decoder, so we can
build it into a larger contextual decoder as needed.

First: the code! If you already know SchemaWax, you don't care about types, and
you're here because it was a hit for "deserialize any enum" on Google this is
the bit to cut and paste.

#+begin_src typescript
  import * as D from "schemawax"

  // This is only type safe if passed a Enum with string values.
  // I don't think there's anyway to stop someone passing { "boo": "broken" }
  // in TypeScripts type system :(
  // At least this stops us from rewriting the same unsafe code every time though.
  export const stringEnumDecoder = <Enum extends { [name: string]: string }>(
    targetEnum: Enum,
  ): D.Decoder<Enum[keyof Enum]> => D.literalUnion(...Object.values(targetEnum)) as D.Decoder<Enum[keyof Enum]>
#+end_src

That's it. The whole thing. How do you use it?

Like this:

#+begin_src typescript
  import * as D from "schemawax"
  import { stringEnumDecoder } from "./enum"

  enum TestEnum1 {
    "why" = "would",
    "anyone" = "do",
    "this" = "!",
  }

  type ObjectWithEnumField = {
    testEnum: TestEnum1
    name: string
    age?: number
  }

  describe("stringEnumDecoder", () => {
    it("decodes string enums", () => {
      const result = stringEnumDecoder(TestEnum1).forceDecode("!")
      expect(result).toEqual(TestEnum1.this)
    })
    it("rejects invalid enum values", () => {
      const result = stringEnumDecoder(TestEnum1).decode("this")
      expect(result).toBeNull()
    })

    it("can be used in larger decoders", () => {
      const objectDecoder: D.Decoder<ObjectWithEnumField> = D.object({
        required: {
          testEnum: stringEnumDecoder(TestEnum1),
          name: D.string,
        },
        optional: {
          dateOfBirth: D.string.andThen((str) => new Date(str)),
        },
      })

      const inputFromApi = `{ "testEnum": "!", "name": "bob", "dateOfBirth": "2022-11-24"}`
      const result1 = objectDecoder.decode(JSON.parse(inputFromApi))
      expect(result1).toEqual({ testEnum: TestEnum1.this, name: "bob", dateOfBirth: new Date("2022-11-24") })
    })
  })
#+end_src

How does this work? How can we write a function that can take an enum type as an
argument, and then generate a decoder? (Feel free to drop out if you were just
here to solve your immediate problem!)

If you type an enum into the online TypeScript playground ([[https://www.typescriptlang.org/play?#code/KYOwrgtgBAYg9nKBvAUFKB5EwoF4oBEc2BANGlACoDui+BALrWSgL4pA][here's one I prepared
earlier]]), you'll see that the enum (with string values) is, in fact, compiled
into a variable that ends up with a simple record with string keys and values
attached to it.

Going back to the implementation, you'll see that's exactly the constraint on
the argument we pass into ~stringEnumDecoder~.

#+begin_src typescript
  ...
  export const stringEnumDecoder = <Enum extends { [name: string]: string }>(... rest of implementation)
#+end_src

Then some slightly weird magic happens: when you pass an enum into the function,
the TypeScript compiler infers that the type of the argument is the ~typeof~ the
enum you passed in. Whatever is happening internally here, it keeps track of the
fact that the keys of this type are the types of the valid enum cases, so it
turns ~Enum[keyof Enum]~ into the union type of each of the possible enum value
types which is, if you squint hard enough, actually the enum itself. We then
return a decoder that accepts a string, checks that said string is actually one
of the /values/ stored in the enum object, and then tells the compiler that this
decoder will only ever return valid enum values. Unfortunately with a cast - but
the full context we need to check this cast is valid is contained within this
one line of code.

So there you have it: a safe way to deserialize strings into enums, and it even
composes nicely into more complex decoders.

Until next time!

Want to comment on something you've read here? [[https://mastodon.sdf.org/@mavnn/109400451463740531][This mastodon post]] is the
official commenting point!
* ADHD and me
:PROPERTIES:
:RSS_PERMALINK: 2022/10/14/adhd_and_me.html
:PUBDATE: 2022-10-14
:ID:       4CE89529-7C27-483C-92DD-BD8D1787C74E
:END:
This morning, I did the washing up.

Now: your first response might be "Michael: why do I care? Do I look like a
washing up blog reader?"

But that would miss the point. This morning I did the washing up, and only the
washing up. I didn't procrastinate with some Twitter or YouTube videos first. I
didn't need to listen to a podcast at the same time to avoid getting lost
staring off into space thinking about something completely different.

Most importantly: no crushing feeling of overwhelm about needing to do this task
that both feels insurmountable but is obviously (objectively) trivial. It's
embarrassing to admit that I've been repeatedly reduced to tears by the need to
do the washing up.

This change, it appears, is the impact of methylphenidate (Ritalin®) on my
brain. I was recently diagnosed with ADHD, and yesterday I undertook a series of
"challenge tests" to see if I am one of the [[https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2732009/][75% of adult's with ADHD whose
symptoms are helped by the drug]].

I did the same series of tests twice: once in the morning, before taking
methylphenidate; the other in the afternoon an hour after taking the first trial
intake under observation (methylphenidate is a controlled substance here in
Italy).

It was a strange, and almost disturbing, experience to feel my brain acting
differently. Recall was smoother. Free association on a topic easier because my
brain stayed on /that/ topic, without veering away onto side lines that I needed
to filter out from what I was saying. My thoughts were still my own, but
with... less in the way.

You see: trying to do stuff (and by stuff I mean pretty much /anything/ that you
need to choose to do, rather than that you happen to start because it distracted
you...) with ADHD is hard. I didn't realize how hard until some of that effort
was lifted.

The closest I've come to being able to describe it is that having ADHD is like
your brain wearing an ancient near eastern tunic to work a farm.

Ever hear the phrase "gird your loins"? It's the [[https://www.artofmanliness.com/skills/manly-know-how/how-to-gird-up-your-loins-an-illustrated-guide/][process of tying up your tunic]]
(designed primarily to keep you cool) so that you can run, or fight, or carry
out hard physical labour at ground level without the 'skirt' of the tunic
getting in the way and tripping you up.

My brain wears a tunic: I need to put effort into preparing to do things before
I can even start doing them. So it takes energy and effort just to /get ready to
start/. And if you make a mistake in the girding, or the knot slips? Well, now
you're half way through your task with a bunch of cloth swishing around your
legs and getting in the way.

Methylphenidate is the equivalent of putting on jeans.[fn:1] You can be casual still,
but you can also just... do stuff? Finish your morning coffee, look across the
kitchen, and go: "I need to do the washing up."

This morning, I did the washing up.

[fn:1] Very short lived jeans, at the moment. While slow release versions are
available, the version of methylphenidate used while experimenting to find the
ideal personal dose has an effect period of about 4-6 hours at the outside and
I'm only prescribed one dose a day. So I still get to wear a brain tunic in the
afternoons until I reach a stable enough dosage to take the slow release
version.
* Teaching (coding) wisdom
:PROPERTIES:
:RSS_PERMALINK: 2022/06/20/teaching-coding-wisdom.html
:PUBDATE: 2022-06-20
:ID:       CDD034DB-37AF-48CB-9AE8-8AEF0DC39A32
:END:
#+begin_quote
[talking about the teaching of wisdom]

There are these distillations that we get throughout the story, like in the ten commandments or in the Sermon on the Mount. At points, it’s very clear: “Don’t murder.” “Honor your ma and pa.” “Do to others what you want them to do to you.” But if you really think about it, you don’t want a list. You might want a list for a certain season that will train your moral compass. Then, when you confront really complex situations, like Joshua or Moses, and it’s not clear, and there’s no list, you’ve been shaped to be the kind of person who knows how to figure out the right way forward. Lists will not help you do that. Wisdom will help you do that.

--- https://bibleproject.com/podcast/wisdom-lifes-complexity/
#+end_quote

Listening to the podcast above earlier and thinking that it feels very similar to how to teach good coding practices. We use the short hand of rules, and lists of recommendations… sometimes. But that doesn’t teach you how to deal with the complex situations, the edge cases, the actual real problems that need solving.

The flip side being that as soon as you’re guided by wisdom, by the stories of what works, the shaping of thinking, you start getting into interpretation and ambiguity because you’re actually needing to think about the decisions you’re making. It can become hard to explain why you’re doing things, and different experiences will have coloured the “wisdom” that you’ve formed over the years. Which is why it becomes so important to have a variety of backgrounds and a willingness to communicate in a technical team that’s actually going to get things done. Why the lists and rules (microservices rule the world! TDD is the one true way! pure code is the only real code!) only get you so far, and should be starting points - not ending points.

If you'd like to comment on this post, or suggest a correction, you can [[https://github.com/mavnn/blog/blob/master/2022/06/20/teaching-coding-wisdom.org][submit suggestions for changes]] (GitHub account required). Just hit the "edit this file button" and go from there - or log an issue on the repository.
* Why your Typescript compiles when you thought you were safe
:PROPERTIES:
:RSS_PERMALINK: 2022/01/07/types-in-typescript.html
:PUBDATE: 2022-01-07
:ID:       D6E23A8A-B4FB-4519-B67C-63B6EABE696B
:END:
#+index: TypeScript!Why unsafe code compiles

** These are not the types you are looking for
:PROPERTIES:
:ID:       995F5F93-2A3F-434A-A95D-4461A836237B
:END:

TypeScript's compiler will let you write code that looks illegal - but compiles just fine.

This is the story of one such piece of code, and the epiphany it led me to: TypeScript doesn't use your type definitions to decide if a type is compatible, it uses the JavaScript that could represent that type.

Let's walk through what that means.

** The code
:PROPERTIES:
:ID:       58877A50-E266-4410-8865-E3465899AAEB
:END:

I'm writing code to make defining GraphQL resolvers a type safe experience (earlier developer feedback for the win). You don't need to know the details of GQL to follow this example though; all you need to know is that I have a type for defining the configuration of a resolver, and once certain information is supplied, I know the config is valid.

Let's have a look at some code:

#+begin_src typescript
  type ConfigValid = "valid" | "invalid"

  class Config<T extends ConfigValid> {
    private myConfig: string | null = null

    private constructor() {}

    public static make(): Config<"invalid"> {
      return new Config<"invalid">()
    }

    // I want this function to only accept valid configurations, and I want to
    // check if they are valid *at compile time*
    public static build(config: Config<"valid">) {
      // do stuff!
      console.log(config.myConfig)
    }
  }
#+end_src

Pop quiz: ~Config.make~ always returns a ~Config<"invalid">~, and ~Config.build~ only takes a ~Config<"valid">~. Will the code ~Config.build(Config.make())~ compile or not?

Given I'm asking, you've probably guessed that it *does* compile, breaking both my intuition... and my code.

Why?

** What actually /is/ TypeScript anyway?
:PROPERTIES:
:ID:       5783333A-6B82-4499-9431-033075EA096E
:END:

Don't get whiplash, I'm going somewhere with this.

What is TypeScript?

Let's hit the [[https://www.typescriptlang.org/][TypeScript website]]. It starts with "TypeScript is JavaScript with syntax for types", and then continues with "TypeScript is a strongly typed programming language that builds on JavaScript, giving you better tooling at any scale". 

To my way of thinking, that first quote looks accurate. The second is a lie.

Okay, okay: "strongly typed" has [[https://en.wikipedia.org/wiki/Strong_and_weak_typing]["no precise technical definition"]] so you can argue that it's half true; I wouldn't agree, given the code above, but you can argue it. But what I'm really calling a lie is the statement that TypeScript is a programming language.

I would instead argue that TypeScript is an inline theorem prover for JavaScript. Because anything that *does* something in your code is really JavaScript - after all, TypeScript compiles to JavaScript, and all your lovely types are erased. While all of the /TypeScript/ in your code (anything that isn't valid JavaScript) is just there trying to prove that your code is correct. 

TypeScript has been designed to make demonstrating correctness as easy as possible when dealing with existing (untyped) JavaScript. (Hint: as easy as possible doesn't mean easy...)

** Erm... what's this got to do with the code above?
:PROPERTIES:
:ID:       34EC9D6E-CBBF-4051-B3ED-DA5533AED73D
:END:

We're not there yet. Stage 2 in our journey is structural typing.

Most strongly typed programming languages use "nominal" typing. Roughly, it's the "name" of the type that matters and if you give two types two different names (not aliases, actual different names), the compiler will keep track of which one you use where and treat them as different things - /even if they hold exactly the same data/.

So in, for example, F#, the following two types are not the same, and a function that accepts one will not accept the other:

#+begin_src fsharp
  type FirstRecord = {
      name: string
  }

  type SecondRecord = {
      name: string
  }

  let withFirstRecord (record: FirstRecord) =
    record.name
#+end_src

Trying to send a record of ~SecondRecord~ to ~withFirstRecord~ would be a compile time error. Now, in F# there's an alternative; the function below will accept any type with a member called ~name~:

#+begin_src fsharp
  let inline withName arg =
    (^a : (member name : string) arg)
#+end_src

Notice a few things here:

** That syntax is horrific; turns out this is a deliberate choice to discourage overuse (see the rest of the bullets for why)
:PROPERTIES:
:ID:       3A5D489D-630B-4A6E-A555-9061365B87D0
:END:
** I had to add the ~inline~ keyword to get it to compile. This literally means that in each place this method is used, the compiler will inline a version that uses the type inferred in that location in the code base. This can be good or bad.
:PROPERTIES:
:ID:       483CFFBD-63C5-4EB2-927E-C5A22DC01BFE
:END:
** You can probably imagine that the error messages from this type of code become explosively unreadable if you nest several layers of functions using this technique, and the constraints start to grow. F# can no longer tell you "you need to give my a ~FirstRecord~"; instead it has to resort to "here's a list of constraints, find me something that meets them all."
:PROPERTIES:
:ID:       FC9FC362-1A33-407A-A814-C85806B45597
:END:

This is structural typing, checking types based on the type of data that they hold. And here we wrap back around to TypeScript, which always uses structural typing. 

The question is: /what/ are we comparing to see if things are structurally compatible? And this is where my intuition was broken.

In F#, we're comparing the *type definition* to the constraints. But in TypeScript, we're comparing the *JavaScript representation of the type* to the constraints /because TypeScript exists to make JavaScript safer/, not to be a programming language in its own right.

** The mystery resolved
:PROPERTIES:
:ID:       25DC8346-E1ED-49C3-B966-98F5E6FD1B47
:END:

Back to our code:   

#+begin_src typescript
  type ConfigValid = "valid" | "invalid"

  class Config<T extends ConfigValid> {
    private myConfig: string | null = null

    private constructor() {}

    public static make(): Config<"invalid"> {
      return new Config<"invalid">()
    }

    // I want this function to only accept valid configurations, and I want to
    // check if they are valid *at compile time*
    public static build(config: Config<"valid">) {
      // do stuff!
      console.log(config.myConfig)
    }
  }
#+end_src

What is the difference between the JavaScript representations of ~Config<"invalid">~ and ~Config<"valid">~?

Answer: nothing.

The generic parameter on the type is not used or stored at runtime (i.e. in JavaScript) on ~Config~, and therefore it gets completely erased when we compile to JavaScript. Suddenly, it becomes no surprise that the compiler is perfectly happy to allow the use of ~Config<"invalid">~ anywhere we specify ~Config<"valid">~ - by TypeScript's standards they are structurally equivalent.

** But: the safety?!
:PROPERTIES:
:ID:       9A8A560B-2569-47ED-AB99-4552393D0CAD
:END:

Okay, so the code above doesn't work. But now we know what the problem actually is, so... let's fix it!

#+begin_src typescript
  type ConfigValid = "valid" | "invalid"

  class Config<T extends ConfigValid> {
    private myConfig: string | null = null
    private _isValid: T

    private constructor(isValid: T) {
      this._isValid = isValid
    }

    public static make(): Config<"invalid"> {
      return new Config<"invalid">("invalid")
    }

    // I want this function to only accept valid configurations, and I want to
    // check if they are valid *at compile time*
    public static build(config: Config<"valid">) {
      // do stuff!
      console.log(config.myConfig)
    }
  }
#+end_src

You see that ~_isValid~ field? Now we're storing a value in that field, and that value will exist at runtime in the compiled JavaScript. Now TypeScript cares about it, and now we can call ~Config.build~ safe in the knowledge it will only take a valid configuration instance.

** That's a wrap
:PROPERTIES:
:ID:       47B8C935-A5BB-4B7A-8F5B-76EE637762A1
:END:

I hope you've enjoyed this little journey into making [[https://blog.janestreet.com/effective-ml-revisited/][making illegal states unrepresentable]], and if you think you could enjoy this kind of thing (or even using the results to just build stuff!) I'm currently working with Blissfully and we're [[https://www.blissfully.com/careers/][currently hiring]] (it says backend developers, but we're also hiring for our Elm frontend where making illegal states unrepresentable is even easier...).

If you feel a burning need to comment on this post, or suggest a correction, you can [[https://github.com/mavnn/blog/blob/master/2022/01/07/types-in-typescript.org][submit suggestions for changes]] (GitHub account required). Just hit the "edit this file button" and go from there.

With special thanks to [[https://twitter.com/mech_elephant][Matthew Griffith]] and [[https://twitter.com/aaronwhite][Aaron White]] for reading, pushing for and suggesting a stronger title and introductory paragraph.
